exit
assert_equal speaker.model.components.get(0).mean(0), model.components.get(0).mean(0)
speaker.model.components.get(0).mean(0)
assert_equal speaker.model.components.get(0).mean(0), model.components.get(0).mean(0)
model.components.get(0).mean(0)
speaker.model.components.get(0).mean(0)
speaker.model.components.get(0)
speaker.model.components.to_a
speaker.model.components
speaker.model
speaker.model.components[0]
speaker.model
exit
gmmlist.java_object.add(model)
gmmlist.java_object.add
gmmlist.java_object
gmmlist.add
gmmlist
model.components.to_a
model.components
model
model.components
model.components.to_a
model.components
gmmlist << model.components
model.components
model.getComponents
model.getComponent
model.debug
model.gaussian
gmmlist
model
model.to_a
model
gmmlist.to_a << model
gmmlist.to_a
gmmlist.java_object << model
gmmlist.java_object
gmmlist
model
model.to_a
model.inspect
model.dump
model.components.get(0).dim
model.components.get(0)
model.components.to_a
model.components
exit
output.close
Rjb::import('fr.lium.spkDiarization.libModel.ModelIO').writerGMMContainer(output, gmmlist)
output.open
output = Rjb::import('fr.lium.spkDiarization.lib.IOFile').new(filename, 'wb')
model
model.to_a
model
model.java_object
model
model.to_a
model
model.java_object
model
gmmlist << model
gmmlist
exit
mult.inject(0, :+)
mult   = ubm_gaussian_weights.each.with_index.inject([]) {|a,(el,ix)| a << el * codiv[ix]}
mult   = ubm_gaussian_weights.each.with_index.inject(0) {|sum,(el, ix)| el * codiv[ix]}
ubm_gaussian_weights[0]
ubm_gaussian_weights
codiv[0]
mult   = ubm_gaussian_weights.each.with_index.inject(0) {|sum,(el, ix)| el * codiv[ix]}
codiv  = Vector.elements(square.each.with_index.inject([]) {|a,(el,ix)| a << el / ubm_covariance[ix]})
square.each.with_index.inject([]) {|a,(el,ix)| a << el / ubm_covariance[ix]}
square.each.with_index.inject([]) {|a,(el,ix)| el / ubm_covariance[ix]}
square
square.each.with_index.inject([]) {|a,(ix,el)| el / ubm_covariance[ix]; a}
square.each.with_index.inject([]) {|a,(ix,el)| el / ubm_covariance[ix]}
square.each.with_index.inject([]) {|a,(ix,el)| a << el / ubm_covariance[ix]}
(0..5).each.with_index
square[0] / ubm_covariance[0]
ubm_covariance[0]
square[0]
square.each_with_index {|el, ix| el / ubm_covariance[ix]}[0]
square.each_with_index {|el, ix| el / ubm_covariance[ix]}
codiv  = codiv.each_with_index {|el, ix| codiv[ix] = el / ubm_covariance[ix] }
codiv
codiv  = codiv.each_with_index {|el, ix| el / ubm_covariance[ix] }
codiv  = codiv.each_with_index {|el| el / ubm_covariance[index] }
codiv = square.dup
square[0]
codiv  = square.map_with_index {|el| el / ubm_covariance.to_a[index] }
square = diff.map {|el| el ** 2}
exit
diff.map {|el| el ** 2}
diff ** 2
exit
ubm_covariance
ubm_gaussian_weights
diff.class
diff
diff = sv1.vector - sv2.vector
diff
square = Matrix.row_vector(diff.to_a) * Matrix.column_vector(diff.to_a)
square = Matrix.row_vector(diff.to_a) * Matrix.row_vector(diff.to_a)
ubm_gaussian_weights / ubm_covariance
exit
ubm_gaussian_weights.class
ubm_gaussian_weights.clas
ubm_gaussian_weights
exit
ubm_gaussian_weights.class
ubm_gaussian_weights
ubm_gaussian_weights / ubm_covariance
ubm_covariance
 Matrix.build(2, 4)
Matrix.column_vector(diff.to_a).class
Matrix.column_vector(diff.to_a)
Matrix.row_vector(diff.to_a) * Matrix.column_vector(diff.to_a)
Matrix.row_vector(diff) * Matrix.column_vector(diff)
diff = sv1.vector - sv2.vector
exit
ma*ma
ma=Matrix.rows([[1,2]])
ma*ma
ma=Matrix.rows([[1,2], [2,3]])
m = Matrix.rows([[1,2], [2,3]])
matrix = Matrix.rows([[1,2], [2,3]])
matrix*matrix
matrix = Matrix.rows(m)
m=[[1,2], [2,3]]
matrix * matrix
matrix = Matrix.rows(m)
m=[[1,2,3], [2,3,4]]
m=[]
m = [[1,2,3], [2,3,4]]
m
_
m=_
[[1,2,3], [2,3,4]]
m=_
m=
[[1,2,3], [2,3,4]]
m = [[1,2,3], [2,3,4]]
d*d
d=Matrix.rows([diff])
Matrix.rows([diff])
Matrix.rows(diff)
diff
diff = sv1.vector - sv2.vector
diff
Matrix.rows(diff)
m.to_a
m
m.to_a<<[1,2]
m<<[1,2]
m=Matrix[]
Matrix[]
m = Matrix[]
Matrix[diff.to_a]
s = m * m
m * m
m
m.columns
m.rows
m=Matrix[diff]
Matrix[diff]
diff.to_matrix
diff
Matrix.elements
Matrix
norm = diff * diff
diff.class
diff.clsas
diff
norm = diff * diff
diff = sv1.vector - sv2.vector
ubm_covariance
ubm_gaussian_weights * ((sv1.vector - sv2.vector) ** 2) / ubm_covariance
ubm_gaussian_weights
exit
v.sum
v=Vector.elements [1,2]
Vector.elements [1,2]
[1,2].sum
ubm_gaussian_weights.mul
ubm_gaussian_weights.class
ubm_gaussian_weights.clsas
ubm_gaussian_weights
ubm_covariance
(sv1.vector - sv2.vector)[0]
sv1.vector[0] - sv2.vector[0]
sv2.vector[0]
sv1.vector[0]
sv1[0]
sv[0]
sv1.vector - sv2.vector
sv1.vector.class
sv1.vector
sv1.class
sv1
exit
gaussian.weight
k * gaussian.dim + i
cont
k * gaussian.dim + i
cont
k * gaussian.dim + i
cont
k * gaussian.dim + i
exit
ubm.model.nb_of_components
weights = Array.new(ubm.supervector.dim, 0)
ubm.supervector.dim
ubm.supervector
ubm
exit
ubm.supervector
ubm.supervector.size
ubm.supervector.dim
ubm.supervector
ubm
exit
vector.size
SuperVector.new(Vector.elements(vector))
vector
exit
vector[k * gaussian.dim + i] = gaussian.mean(i)
gaussian.mean(i)
k * gaussian.dim + i
dim
gaussian.dim
gaussian
k
exit
require "jblas"
exit
Matrix.build(3, 3)[0]
Matrix.build(3, 3)
Matrix.new
Vector.new
Vector
require 'matrix'
Vector
DoubleMatrix
dim = model.nb_of_components * model.components.get(0).dim
model.components.get(0).dim
model.components.get(0)
model.components
model.nb_of_components
exit
model.java_object.nb_of_components
model.java_object
model
exit
SuperVector
exit
